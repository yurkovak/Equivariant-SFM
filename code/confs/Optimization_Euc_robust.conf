exp_name = Optimization_Euc
num_iter = 1
random_seed = 0
dataset
{
    use_gt = False
    calibrated = True
    scan = Drinking Fountain Somewhere In Zurich
    scans_list = ["Alcatraz Courtyard","Alcatraz Water Tower","Buddah Tooth Relic Temple Singapore","Doge Palace Venice",
         "Door Lund","Drinking Fountain Somewhere In Zurich","East Indiaman Goteborg","Ecole Superior De Guerre",
         "Eglise du dome","Folke Filbyter","Fort Channing Gate Singapore","Golden Statue Somewhere In Hong Kong",
         "Gustav Vasa","GustavIIAdolf","Jonas Ahlstromer","Kings College University Of Toronto",
         "Lund University Sphinx","Nijo Castle Gate","Pantheon Paris","Park Gate Clermont Ferrand",
         "Plaza De Armas Santiago","Porta San Donato Bologna","Round Church Cambridge","Skansen Kronan Gothenburg",
         "Smolny Cathedral St Petersburg","Some Cathedral In Barcelona","Sri Mariamman Singapore",
         "Sri Thendayuthapani Singapore","Sri Veeramakaliamman Singapore","Statue Of Liberty","The Pumpkin",
         "Thian Hook Keng Temple Singapore","Tsar Nikolai I","Urban II","Vercingetorix",
         "Yueh Hai Ching Temple Singapore","dtu106","dtu500","dtu700"]
    # a percentage of random noise, [0, 1)
    outliers_ratio = 0.0
    # a percentage of track to be damaged [0, 1)
    damaged_track_ratio = 0.1
    # withing each track selected for damaging, num outliers given as a percentage of existing points in this track
    track_outliers_ratio = 1.5
}
model
{
    type = SetOfSet.SetOfSetNet
    layer_type = SetOfSetLayerSelfAttention
    layer_extra_params = {
      add_residual = True
      num_heads = 1  # num_features must be divisible by num_heads
      track_attention = True
      camera_attention = True
      add_norm = True
    }
    num_features = 256
    num_blocks = 1
    block_size = 3
    use_skip = False
    multires = 0
}
train
{
    lr = 1e-4
    num_of_epochs = 1e+5
    scheduler_milestone = [50000, 70000, 90000]
    gamma = 0.1
    eval_intervals = 5000
    optim_type = Lion
}
loss
{
    func = ESFMLoss
    infinity_pts_margin = 1e-4
    normalize_grad = True
    hinge_loss = True
    hinge_loss_weight = 1
}
ba
{
run_ba = False
repeat=True
triangulation=False  # If repeat, the first time is from our points and the second from triangulation
only_last_eval = True
}


# python3 single_scene_optimization.py --conf Optimization_Euc_robust.conf --external_params "dataset:damaged_track_ratio:0.1,dataset:track_outliers_ratio:1.5" --exp_version track_noise_0-1_1-5_mean-att-skip